#!/bin/bash

# Path to the JSON configuration file
K4ALL_CONFIG_FILE="/etc/k4all-config.json"

retry_command() {
  local command="$1"
  local max_retries="$2"
  local delay="$3"
  local retry_count=0
  local success=false

  while [ "$retry_count" -lt "$max_retries" ]; do
    echo "Attempt $(($retry_count + 1))..."

    # Execute the command
    if eval "$command"; then
      echo "Command executed successfully."
      success=true
      break
    else
      echo "Command failed. Retrying in $delay seconds..."
      retry_count=$(($retry_count + 1))
      sleep "$delay"
    fi
  done

  # Check if we succeeded after all retries
  if [ "$success" = false ]; then
    echo "Command failed after $max_retries retries."
    return 1
  fi
}

# Function to set up kubeconfig for a specified user
function setup_kubeconfig_for_user() {
  local user_name=$1
  local user_home=$2
  local override_file_name=${3:-"admin.conf"}

  mkdir -p "${user_home}/.kube"
  cp /etc/kubernetes/${override_file_name} "${user_home}/.kube/config"
  chown "${user_name}:${user_name}" "${user_home}/.kube/config"
}

# Function to finalize the setup for a specified user
finalize_k8s_setup_for_user() {
  local user_name=$1
  local user_home=$2

  # Ensure the .kube directory exists
  mkdir -p "${user_home}/.kube"

  # Generate the kubectl completion script
  local completion_file="${user_home}/.kube/completion.bash.inc"
  kubectl completion bash > "$completion_file"

  # Source the completion script in the user's .bash_profile if not already sourced
  local source_string="source '$completion_file'"
  if ! grep -qF "$source_string" "${user_home}/.bash_profile"; then
    printf "\n# kubectl shell completion\n$source_string\n" >> "${user_home}/.bash_profile"
  fi
}

function get_network_device() {
    # Check if the configuration file exists
    if [ ! -f "$K4ALL_CONFIG_FILE" ]; then
        # Configuration file does not exist, use the default network interface
        ip route show default | awk '/default/ {print $5; exit}'  # Exit after the first match
        return
    fi

    # Extract the net_dev value from the JSON configuration file
    local net_dev=$(jq -r '.networking."net_dev"' "$K4ALL_CONFIG_FILE")
    
    # Check if the net_dev is set to auto
    if [ "$net_dev" = "auto" ]; then
        # Find the default network interface used for the first default route
        net_dev=$(ip route show default | awk '/default/ {print $5; exit}')  # Exit after the first match
    fi

    # Output the result
    echo $net_dev
}
